<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最大的矩形</title>
    <url>/2021/03/16/acm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p><a href="http://118.190.20.162/view.page?gpid=T3">题目链接</a></p>
<p><img src="https://gitee.com/qztanging/images/raw/master/img/acm_1.png" alt="题目描述" title="描述"><br><span id="more"></span></p>
<p><img src="https://gitee.com/qztanging/images/raw/master/img/acm_2.png" alt="题目描述"></p>
<hr>
<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><ul>
<li>首先看数据范围：1&lt;= n &lt;= 1000 &amp;&amp; 1&lt;= hi &lt;= 10000 ,需要时间复杂度小于等于 O(n<sup>2</sup>) </li>
<li>确定枚举的对象，本题中可以枚举矩形的上边界。知道矩形的上边界和左右边界之后就可以确定一个矩形。枚举矩形的上边界，设横坐标为 i ，高度为 h，经过观察可以发现，上边界确定之后，以该边为上边界的最大矩形就可以确定：左边界为 i 前左数高度第一个小于 h 的；右边界为i 后往右数高度第一个小于 h 的。之后更新最大矩形。</li>
</ul>
<hr>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> n,re,ans;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="comment">//枚举上边界</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = i,r = i;</span><br><span class="line">        <span class="comment">//搜索左边界</span></span><br><span class="line">		<span class="keyword">while</span>(l&gt;= <span class="number">1</span> &amp;&amp; h[l]&gt;= h[i])&#123;</span><br><span class="line">			l--;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//搜索右边界</span></span><br><span class="line">		<span class="keyword">while</span>(r &lt;= n &amp;&amp; h[r] &gt;= h[i])&#123;</span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//计算矩形面积，注意r - l之后需要减1.</span></span><br><span class="line">		re = (r - l - <span class="number">1</span>)*h[i];</span><br><span class="line">		ans = max(re,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的数</title>
    <url>/2021/03/17/acm2-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、-题目描述"><a href="#一、-题目描述" class="headerlink" title="一、 题目描述"></a>一、 题目描述</h2><p><a href="http://118.190.20.162/view.page?gpid=T2">题目链接</a></p>
<p><img src="https://gitee.com/qztanging/images/raw/master/img/a.jpg" alt="描述"><br><span id="more"></span></p>
<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><ul>
<li><p>题目中有三个要求，可以将0和1看作第一类，2和3看作第一类，然后就是排列组合问题。</p>
</li>
<li><p>首先设第一类数个数为 <strong>k</strong> ，则第二类数个数为 <strong>n - k</strong>。<strong>k</strong>的范围为：[2 ，n - 2] </p>
</li>
<li><p>从k个位置中选取第一类的位置，因为最高为不能为0，所以第一类的可能位置有 :</p>
<script type="math/tex; mode=display">
C_{n-1}^{k}</script></li>
<li><p>之后具体分第一类中0和1的位置，因为 <strong>0</strong> 在<strong>1</strong>的前面且必须有一个，所以第一类里面的情况有  <strong>k-1</strong> 种：01111…11(一个0和k-1个1)  和00111…111(两个0和k-2个1)  到 0000…0001  (k-1个0和共1个1)。</p>
</li>
<li><p>同理第二类数字中的位置情况： <strong>n - k - 1</strong>种。</p>
</li>
<li><p><strong>综上所述</strong>，方案数为：</p>
<script type="math/tex; mode=display">
\sum_{k=2}^{n-2}  C_{n-1}^{k} \times (k-1) \times (n-k-1)</script></li>
</ul>
<hr>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>,mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,re,t,c[N][N];</span><br><span class="line"><span class="comment">//组合数数组的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;= i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)  c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n<span class="number">-2</span> ; i++)&#123;</span><br><span class="line">        <span class="comment">//因为可能超范围，所以转换为long,相乘的中间也要模一下</span></span><br><span class="line">        re =( re +  (ll)c[n<span class="number">-1</span>][i]*(i<span class="number">-1</span>)%mod  *(n<span class="number">-1</span>-i)  )%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式性质</title>
    <url>/2021/03/22/xd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、上三角行列式与下三角行列式"><a href="#一、上三角行列式与下三角行列式" class="headerlink" title="一、上三角行列式与下三角行列式"></a>一、上三角行列式与下三角行列式</h2><h3 id="1-上三角行列式"><a href="#1-上三角行列式" class="headerlink" title="1. 上三角行列式"></a>1. 上三角行列式</h3><ul>
<li>定义：主对角线以下全部为0的行列式称为上三角行列式。</li>
<li>上三角行列式的值为主对角线的乘积。</li>
</ul>
<span id="more"></span>
<ul>
<li><strong>例：(以四阶为例)</strong></li>
</ul>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a_{11}&&a_{12}&&a_{13}&&a_{14}\\
0&&a_{22}&&a_{23}&&a_{24}\\
0&&0&&a_{33}&&a_{34}\\
0&&0&&0&&a_{44}
\end{array}
\right|
=a_{11}a_{22}a_{33}a_{44}</script><h3 id="2-下三角行列式"><a href="#2-下三角行列式" class="headerlink" title="2. 下三角行列式"></a>2. 下三角行列式</h3><ul>
<li>定义：副对角线以下全部为0的行列式称为而下三角行列式。</li>
<li>下三角行列式的值为副对角线的乘积乘以 $(-1)^{\frac{1}{2}n(n-1)}$。</li>
<li><strong>例：(以四阶为例)</strong></li>
</ul>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a_{11}&&a_{12}&&a_{13}&&a_{14}\\
a_{21}&&a_{22}&&a_{23}&&0\\
a_{31}&&a_{32}&&0&&0\\
a_{41}&&0&&0&&0
\end{array}
\right|
=(-1)^{\frac{1}{2}n(n-1)}a_{14}a_{23}a_{32}a_{41}</script><h3 id="3-tips"><a href="#3-tips" class="headerlink" title="3. tips"></a>3. <font color=red>tips</font></h3><p>二阶与三阶行列式的对角线法到四阶行列式失灵，计算四阶行列式必须用展开公式法(根据定义展开)。</p>
<h2 id="二、行列式的性质"><a href="#二、行列式的性质" class="headerlink" title="二、行列式的性质"></a>二、行列式的性质</h2><h3 id="1-行列互换，行列式的值不变"><a href="#1-行列互换，行列式的值不变" class="headerlink" title="1. 行列互换，行列式的值不变"></a>1. 行列互换，行列式的值不变</h3><p><img src="https://i.loli.net/2021/03/22/MZdV1QK9Y2v5XNR.png" alt="image-20210322195357646"></p>
<h3 id="2-对换行列式中两行的位置，行列式变号"><a href="#2-对换行列式中两行的位置，行列式变号" class="headerlink" title="2. 对换行列式中两行的位置，行列式变号"></a>2. 对换行列式中两行的位置，行列式变号</h3><p><img src="https://i.loli.net/2021/03/22/IY1Q3cJbLCU2A4f.png" alt="image-20210322201715848"></p>
<p><strong>推论：行列式两行<font color=red>成比例</font>，则行列式为$0$。</strong></p>
<h3 id="3-某行有公因数-k-可以将-k-提出"><a href="#3-某行有公因数-k-可以将-k-提出" class="headerlink" title="3. 某行有公因数$k$可以将$k$提出"></a>3. 某行有公因数$k$可以将$k$提出</h3><p><img src="https://i.loli.net/2021/03/22/YZFsOKl3kGxRgpN.png" alt="image-20210322201250223"></p>
<p> <strong>推论：若某一行元素全为$0$，则可以将$0$提出来，所以行列式的值为$0$。</strong></p>
<h3 id="4-行列式某行或某列是两个元素之和，则可以将行列式拆成两个行列式之和"><a href="#4-行列式某行或某列是两个元素之和，则可以将行列式拆成两个行列式之和" class="headerlink" title="4.行列式某行或某列是两个元素之和，则可以将行列式拆成两个行列式之和"></a>4.行列式某行或某列是两个元素之和，则可以将行列式拆成两个行列式之和</h3><p><img src="https://i.loli.net/2021/03/22/ZWnUfk3aLObA47N.png" alt="image-20210322202322696"></p>
<h3 id="5-某行的-k-倍加到另一行，行列式的值不变"><a href="#5-某行的-k-倍加到另一行，行列式的值不变" class="headerlink" title="5.某行的$k$倍加到另一行，行列式的值不变"></a>5.某行的$k$倍加到另一行，行列式的值不变</h3><p><img src="https://i.loli.net/2021/03/22/K5hwYbCirdVeSIU.png" alt="image-20210322202747554"></p>
<h2 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h2><p>已知$306,527,918$都能被$17$整除，不计算行列式的值，证明：</p>
<script type="math/tex; mode=display">
D=
\left|
\begin{array}
{ccc}
6&&7&&8\\
0&&2&&1\\
3&&5&&9
\end{array}
\right|,能被17整除。</script><p>证明：因为行列式是不同行不同列元素乘积的代数和，所以$D$必是一个整数。</p>
<p>将第三行的$100$倍，第二行的$10$倍都加到第一行，行列式的值不变，得到：</p>
<script type="math/tex; mode=display">
D=
\left|
\begin{array}
{ccc}
306&&527&&918\\
0&&2&&1\\
3&&5&&9
\end{array}
\right|=17k</script><p>故$D$能被$17$整除。</p>
]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式概念</title>
    <url>/2021/03/21/post/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、二三阶行列式"><a href="#一、二三阶行列式" class="headerlink" title="一、二三阶行列式"></a>一、二三阶行列式</h2><h3 id="1-二阶行列式定义"><a href="#1-二阶行列式定义" class="headerlink" title="1. 二阶行列式定义"></a>1. 二阶行列式定义</h3><script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a&&b\\
c&&d
\end{array}
\right|
=ad-bc</script><p>同时从左上到右下称为<strong>主对角线</strong>，左下到右上称为<strong>副对角线</strong>。</p>
<span id="more"></span>
<h3 id="2-代入一元二次方程组"><a href="#2-代入一元二次方程组" class="headerlink" title="2. 代入一元二次方程组"></a>2. 代入一元二次方程组</h3><p>对于一元二次方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
a_1x+b_1y=c_1\\
a_2x+b_2y=c_2
\end{cases}</script><p>通过加减消元，我们可以得到：</p>
<script type="math/tex; mode=display">
(a_1b_2-a_2b_1)x=c_1b_2-c_2b_1\\
(a_2b_1-a_1b_2)y=c_1a_2-c_2a_1</script><p>如果系数行列式</p>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a_1&&b_1\\
a_2&&b_2
\end{array}
\right|
=a_1b_2-a_2b_1\neq0</script><p>则方程组有唯一解，即：</p>
<script type="math/tex; mode=display">
\begin{cases}
x=
\frac
{\left|
\begin{array}
{ccc}
c_1&&b_1\\
c_2&&b_2
\end{array}
\right|}
{\left|
\begin{array}
{ccc}
a_1&&b_1\\
a_2&&b_2
\end{array}
\right|}\\
y=
\frac
{\left|
\begin{array}
{ccc}
a_1&&c_1\\
a_2&&c_2
\end{array}
\right|}
{\left|
\begin{array}
{ccc}
a_1&&b_1\\
a_2&&b_2
\end{array}
\right|}
\end{cases}</script><p>例：解下列方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
3x+2y=5\\
5x-7y=29
\end{cases}</script><blockquote>
<p>解：由于系数行列式</p>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
3&&2\\5&&-7
\end{array}
\right|
=-21-10=-31\neq0</script><p>所以方程组有唯一解</p>
<p>所以：</p>
<script type="math/tex; mode=display">
x=
\frac
{\left|
\begin{array}
{ccc}
5&&2\\29&&-7
\end{array}
\right|}
{-31}=3,
y=
\frac
{\left|
\begin{array}
{ccc}
3&&5\\5&&29
\end{array}
\right|}
{-31}=-2</script></blockquote>
<h3 id="3-三阶行列式"><a href="#3-三阶行列式" class="headerlink" title="3. 三阶行列式"></a>3. 三阶行列式</h3><script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a_{11}&&a_{12}&&a_{13}\\
a_{21}&&a_{22}&&a_{23}\\
a_{31}&&a_{32}&&a_{33}
\end{array}
\right|=\\a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-\\a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{
23}a_{32}</script><font color=red>不同行不同列元素乘积的代数和</font>



<hr>
<h2 id="二、排列、逆序、逆序数"><a href="#二、排列、逆序、逆序数" class="headerlink" title="二、排列、逆序、逆序数"></a>二、排列、逆序、逆序数</h2><h3 id="1-排列"><a href="#1-排列" class="headerlink" title="1. 排列"></a>1. 排列</h3><blockquote>
<p>排列：由1,2,···,n组成的有序数组称为一个 <strong>n</strong> 阶排列。通常用 $j_1,j_2,j_3,···,j_n$表示 <strong>n</strong>阶排列。</p>
<p>自然排列：从1到n从小到大顺序排列成为自然排列。</p>
</blockquote>
<p>例： 2    4     1    3    ：4阶排列</p>
<p>​        1    3    5    4    2    ：5阶排列</p>
<h3 id="2-逆序与逆序数"><a href="#2-逆序与逆序数" class="headerlink" title="2. 逆序与逆序数"></a>2. 逆序与逆序数</h3><blockquote>
<p>逆序：在一个排列中，如果一个大的数排在一个小的数前面，就称这两个数构成一个逆序。</p>
<p>逆序数：一个排列中逆序的总数为这个排列的逆序数。用$\tau(j_1,j_2,···,j_n)$表示相关排列的逆序数。</p>
<p>偶排列：如果一个排列的逆序数为偶数，则称这个排列为偶排列</p>
<p>奇排列：如果一个排列的逆序数为奇数，则称这个排列为奇排列</p>
</blockquote>
<p>例：$\tau(1\,3\,2)=0+1=1$</p>
<p>​        $\tau(2\,4\,3\,1)=1+2+1=4$</p>
<h3 id="3-定理"><a href="#3-定理" class="headerlink" title="3.定理"></a>3.定理</h3><ul>
<li>对换改变排列的奇偶性</li>
<li>任意一个$n$阶排列可经过一系列兑换变成自然排列</li>
<li>在所有的$n$阶排列中，奇偶排列各占一半</li>
</ul>
<hr>
<h2 id="三、n阶行列式概念"><a href="#三、n阶行列式概念" class="headerlink" title="三、n阶行列式概念"></a>三、n阶行列式概念</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><img src="https://i.loli.net/2021/03/21/rpPKtdU9Tsq1vRk.png" alt="定义"></p>
<p>完全展开式有$n!$项。</p>
]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式展开式</title>
    <url>/2021/03/23/xd3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、代数余子式"><a href="#一、代数余子式" class="headerlink" title="一、代数余子式"></a>一、代数余子式</h2><span id="more"></span>
<p>在$n$阶行列式中划去$a<em>{ij}$所在的第$i$行、第$j$列的元素，由剩下的元素按照原来位置排法构成的一个$n-1$阶的行列式，称其为$a</em>{ij}$的余子式，记为$M<em>{ij}$；称$(-1)^{i+j}M</em>{ij}$为$a<em>{ij}$的代数余子式，记为$A</em>{ij}$，即$A<em>{ij}=(-1)^{i+j}M</em>{ij}$</p>
<ul>
<li><strong>余子式</strong> ：划去一行一列之后的$n-1$阶行列式，称为$a<em>{ij}$的余子式，记为$M</em>{ij}$</li>
<li><strong>代数余子式</strong> :在余子式前乘以$(-1)^{i+j}$，记为$A_{ij}$</li>
</ul>
<h2 id="二、行列式按行按列展开"><a href="#二、行列式按行按列展开" class="headerlink" title="二、行列式按行按列展开"></a>二、行列式按行按列展开</h2><p><img src="https://i.loli.net/2021/03/23/72MOfFQ4KDwGHTp.png" alt="image-20210323155606062"></p>
<p><img src="https://i.loli.net/2021/03/23/WHfT9vk7lyhzmCi.png" alt="image-20210323160123620"></p>
<h2 id="三、范德蒙行列式"><a href="#三、范德蒙行列式" class="headerlink" title="三、范德蒙行列式"></a>三、范德蒙行列式</h2><p>链接：<a href="https://baike.baidu.com/item/%E8%8C%83%E5%BE%B7%E8%92%99%E8%A1%8C%E5%88%97%E5%BC%8F/6081288?fr=aladdin">范德蒙行列式定义</a></p>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
1&&1&&1&&…&&1\\
a_1&&a_2&&a_3&&…&&a_n\\
a^2_{1}&&a^2_{2}&&a^2_{3}&&…&&a^2_{n}\\
\vdots&&\vdots&&\vdots&&\vdots&&\vdots\\
a_1^{n-1}&&a_2^{n-1}&&a_3^{n-1}&&…&&a_n^{n-1}
\end{array}
\right|
=\prod_{1\le j<i\le n}^{n}(a_i-a_j)</script><p>即：大坐标数减小坐标数的连乘器。</p>
<p>例.  求解下列行列式:</p>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
1&&2&&3&&4\\
1&&2^2&&3^2&&4^2\\
1&&2^3&&3^3&&4^3\\
9&&8&&7&&6
\end{array}
\right|</script><p>解：将第一行加到第四行上,提取公因式，再构造范德蒙行列式</p>
<script type="math/tex; mode=display">
D=
\left|
\begin{array}
{ccc}
1&&2&&3&&4\\
1&&2^2&&3^2&&4^2\\
1&&2^3&&3^3&&4^3\\
10&&10&&10&&10
\end{array}
\right|
=10
\left|
\begin{array}
{ccc}
1&&2&&3&&4\\
1&&2^2&&3^2&&4^2\\
1&&2^3&&3^3&&4^3\\
1&&1&&1&&1
\end{array}
\right|\\
=-10
\left|
\begin{array}
{ccc}
1&&1&&1&&1\\
1&&2&&3&&4\\
1&&2^2&&3^2&&4^2\\
1&&2^3&&3^3&&4^3
\end{array}
\right|</script><p>所以$D=-10(2-1)(3-1)(4-1)(3-2)(4-2)(4-3)=-120$</p>
<hr>
<h2 id="四、克拉默法则"><a href="#四、克拉默法则" class="headerlink" title="四、克拉默法则"></a>四、克拉默法则</h2><p><img src="https://i.loli.net/2021/03/23/PIeroQLJaAFGZDn.png" alt="image-20210323230740265"></p>
]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2021/03/23/xd2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、矩阵的定义及运算"><a href="#一、矩阵的定义及运算" class="headerlink" title="一、矩阵的定义及运算"></a>一、矩阵的定义及运算</h2><p><img src="https://i.loli.net/2021/03/23/kf6ghYJGdUZbWKD.png" alt="image-20210323231848819"></p>
<p>注意：<font color =red>矩阵$A$是一个表格，而行列式$|A|$是一个数。</font></p>
<span id="more"></span>
<h2 id="二、常见的矩阵"><a href="#二、常见的矩阵" class="headerlink" title="二、常见的矩阵"></a>二、常见的矩阵</h2><ul>
<li>单位矩阵：主对角线元素为$1$，其余元素为$0$的矩阵为单位矩阵，记为$E$</li>
<li>对角矩阵：非对角元素都是$0$的矩阵(即$\forall i \neq j$恒有$a_{ij}=0$)成为对角矩阵</li>
<li>上(下)三角矩阵：当$i&gt;j(i&lt;j)$时，有$a_{ij}=0$称为上(下)三角矩阵</li>
<li>对称矩阵：满足$A^{T}=A$ ，即 $a<em>{ij}=a</em>{ji}$的矩阵称为对称矩阵</li>
<li>反对称矩阵：满足$A^{T}=-A$,即$a<em>{ij}=-a</em>{ji},a_{ii}=0$的矩阵称为反对称矩阵</li>
</ul>
<h2 id="三、矩阵的运算"><a href="#三、矩阵的运算" class="headerlink" title="三、矩阵的运算"></a>三、矩阵的运算</h2><ul>
<li>加法</li>
</ul>
<p><img src="https://i.loli.net/2021/03/24/LHJ9V7nswEkCNR3.png" alt="image-20210324120024689"></p>
<ul>
<li><p>数乘</p>
<p><img src="https://i.loli.net/2021/03/24/VFrgKeEcixw7N5U.png" alt="image-20210324120039681"></p>
</li>
<li><p>乘法</p>
<p><img src="https://i.loli.net/2021/03/24/OrlcXfxzmD6WiH8.png" alt="image-20210324120132691"></p>
</li>
<li><p>转置</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/24/AVOg6UBdm1Mk5Cj.png" alt="image-20210324120155384"></p>
<ul>
<li><font color =red>tips</font> <ol>
<li>$AB \neq BA$</li>
<li>由$AB=0 \nRightarrow A=0$或$B=0$</li>
<li>由$AB=AC$且$A \neq 0 \nRightarrow B=C$</li>
</ol>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/24/dIAJC9HxiyGuqV7.png" alt="image-20210324161522082"></p>
<hr>
<p>对角矩阵运算：</p>
<ul>
<li>相乘</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix} a_1 & 0 &0 \\ 0 & a_2&0\\0&0&a_3 \end{bmatrix}
\begin{bmatrix} b_1 & 0 &0 \\ 0 & b_2&0\\0&0&b_3 \end{bmatrix}=
\begin{bmatrix} a_1b_1 & 0 &0 \\ 0 & a_2b_2&0\\0&0&a_3b_3 \end{bmatrix}</script><ul>
<li>n次方</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix} a_1 & 0 &0 \\ 0 & a_2&0\\0&0&a_3 \end{bmatrix}^{n}=
\begin{bmatrix} a_1^{n} & 0 &0 \\ 0 & a_2^{n}&0\\0&0&a_3^{n} \end{bmatrix}</script><ul>
<li>逆矩阵</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix} a_1 & 0 &0 \\ 0 & a_2&0\\0&0&a_3 \end{bmatrix}
\begin{bmatrix} \frac{1}{a_1} & 0 &0 \\ 0 & \frac{1}{a_2}&0\\0&0&\frac{1}{a_3} \end{bmatrix}=
\begin{bmatrix} 1 & 0 &0 \\ 0 & 1&0\\0&0&1 \end{bmatrix}\\
所以,
\begin{bmatrix} a_1 & 0 &0 \\ 0 & a_2&0\\0&0&a_3 \end{bmatrix}^{-1}=
\begin{bmatrix} \frac{1}{a_1} & 0 &0 \\ 0 & \frac{1}{a_2}&0\\0&0&\frac{1}{a_3} \end{bmatrix}</script>]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>可逆矩阵</title>
    <url>/2021/03/24/xd4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<hr>
<h2 id="一、方阵的行列式"><a href="#一、方阵的行列式" class="headerlink" title="一、方阵的行列式"></a>一、方阵的行列式</h2><blockquote>
<p>设$A=[a_{ij}]$为$n$阶矩阵。其所有元素所构成的行列式称为方阵$A$的行列式，记为$|A|$</p>
</blockquote>
<span id="more"></span>
<p>tips:</p>
<ol>
<li><p>只有方阵才有行列式$A$</p>
</li>
<li><p>$A=0$和$|A|=0$不要混</p>
<p><img src="https://i.loli.net/2021/03/24/jtH5nJlC7orEdQv.png" alt="image-20210324215634667"></p>
</li>
</ol>
<p>方阵行列式公式:</p>
<p><img src="https://i.loli.net/2021/03/28/Nm1OAEkMasvrXo3.png" alt="image-20210328113835852"></p>
<hr>
<h2 id="二、伴随矩阵"><a href="#二、伴随矩阵" class="headerlink" title="二、伴随矩阵"></a>二、伴随矩阵</h2><p><img src="https://i.loli.net/2021/03/24/92AhxGQozslTBMg.png" alt="image-20210324222507399"></p>
<p><img src="https://i.loli.net/2021/03/24/dMLFBK12PryOR9X.png" alt="image-20210324222615805"></p>
<p><font color =red>tips:二阶方阵的伴随矩阵：主对角线互换，副对角线变号</font></p>
<script type="math/tex; mode=display">
A=
\begin{bmatrix} 1 & 2 \\ -1 & 3 \end{bmatrix}
,则|A|=3-(-2)=5,
A*=
\begin{bmatrix} 3 & -2 \\ 1 & 1 \end{bmatrix}\\
A^{-1}= \frac{1}{5}A*</script><hr>
<h2 id="三、可逆矩阵"><a href="#三、可逆矩阵" class="headerlink" title="三、可逆矩阵"></a>三、可逆矩阵</h2><blockquote>
<p>对于$n$阶矩阵A，如果存在n阶矩阵B，使得$AB=BA=E$,则称矩阵A是可逆的，称B为A的逆矩阵，记作$A^{-1}=B$</p>
</blockquote>
<p>定理： </p>
<ul>
<li>若A可逆，则A的逆矩阵唯一。</li>
<li>A可逆$\Leftrightarrow |A| \neq 0$ </li>
<li>设A和B为n阶矩阵且$AB=E$,则$BA=E$</li>
</ul>
<p>逆矩阵的运算性质</p>
<p><img src="https://i.loli.net/2021/03/24/KDzBQt21LH3sTES.png" alt="image-20210324224120395"></p>
<hr>
<h2 id="四、求逆矩阵"><a href="#四、求逆矩阵" class="headerlink" title="四、求逆矩阵"></a>四、求逆矩阵</h2><p><img src="https://i.loli.net/2021/03/24/LfT2PEnUj6mrZHS.png" alt="image-20210324225302181"> </p>
<hr>
<h2 id="五、分块矩阵的运算"><a href="#五、分块矩阵的运算" class="headerlink" title="五、分块矩阵的运算"></a>五、分块矩阵的运算</h2><ol>
<li>加法</li>
</ol>
<script type="math/tex; mode=display">
\begin{bmatrix} A_1 & A_2 \\ A_3 & A_4 \end{bmatrix}+
\begin{bmatrix} B_1 & B_2 \\ B_3 & B_4 \end{bmatrix}=
\begin{bmatrix} A_1+B_1 & A_2+B_2 \\ A_3+B_3 & A_4+B_4 \end{bmatrix}</script><pre><code>2. 乘法
</code></pre><script type="math/tex; mode=display">
\begin{bmatrix} A_1 & A_2 \\ A_3 & A_4 \end{bmatrix}
\begin{bmatrix} B_1 & B_2 \\ B_3 & B_4 \end{bmatrix}=
\begin{bmatrix} A_1B_1+A_2B_3 & A_1B_2+A_2B_4 \\ A_3B_1+A_4B_3 & A_3B_2+A_4B_4 \end{bmatrix}</script><pre><code>3. 转置
</code></pre><script type="math/tex; mode=display">
\begin{bmatrix} A & B \\ C & D \end{bmatrix}^{T}=
\begin{bmatrix} A^{T} & C^T \\ B^T &D^T\end{bmatrix}</script><pre><code>4. $n$次方 
</code></pre><script type="math/tex; mode=display">
\begin{bmatrix} A & 0 \\ 0 & B \end{bmatrix}^n=
\begin{bmatrix} A^n & 0 \\ 0 & B^n \end{bmatrix}</script><p>​    5. 逆矩阵    </p>
<script type="math/tex; mode=display">
\begin{bmatrix} A & 0 \\ 0 & B \end{bmatrix}^{-1}=
\begin{bmatrix} A^{-1} & 0 \\ 0 & B^{-1} \end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix} 0 & A \\ B & 0 \end{bmatrix}^{-1}=
\begin{bmatrix} 0 & B^{-1} \\ A^{-1} & 0 \end{bmatrix}</script>]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵的初等变换与初等矩阵</title>
    <url>/2021/03/26/xd5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、-矩阵初等变换"><a href="#一、-矩阵初等变换" class="headerlink" title="一、 矩阵初等变换"></a>一、 矩阵初等变换</h2><p>设A是$m \times n$矩阵，</p>
<ol>
<li>用某个非零常数k乘A的某行(列)的每个元素</li>
<li>互换A的某两行(列)的位置</li>
<li>将A的某行(列)的k倍加到另一行(列)</li>
</ol>
<p><strong>称为矩阵的三种初等行(列)变换，且分别称为初等倍乘、互换、倍加行(列)变换，统称为初等变换。</strong></p>
<span id="more"></span>
<p><strong>例子：</strong>解下列方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
x_1+x_2+3x_3=1\\
x_1-x_2-x_3=-3\\
5x_1+x_2+7x_3=-3
\end{cases}</script><p>解：对增广矩阵做初等行变换：</p>
<script type="math/tex; mode=display">
\overline{A}=
\begin{bmatrix} 1 & 1&3&1 \\ 1&-1&-1&3 \\5&1&7&-3\end{bmatrix}=
\begin{bmatrix} 1 & 1&3&1 \\ 0&-2&-4&2  \\0&-4&-8&-8\end{bmatrix}\\=
\begin{bmatrix} 1 & 1&3&1 \\ 0&1&2&2 \\0
&0&0&0\end{bmatrix}=
\begin{bmatrix} 1 & 0&1&-1 \\ 0&1&2&2 \\0
&0&0&0\end{bmatrix}</script><p>解方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
x_1+x_3=-1\\
x_2+2x_3=2
\end{cases}</script><p>$x_3$为<strong>自由变量</strong></p>
<p>设$x_3$为$t$，则解为$\begin{cases}x_1=-1-t\x_2=2-2t\x_3=t\end{cases}$或$\begin{bmatrix} x_1\x_2\x_3 \end{bmatrix}=\begin{bmatrix} -1\2\0 \end{bmatrix}+t\begin{bmatrix}{-1}\{-2} \1\end{bmatrix}$</p>
<hr>
<h2 id="二、初等矩阵"><a href="#二、初等矩阵" class="headerlink" title="二、初等矩阵"></a>二、初等矩阵</h2><p><strong>由单位矩阵经过一次初等变换得到的矩阵称为初等矩阵</strong>，分别为：</p>
<ol>
<li>倍乘初等矩阵</li>
<li>互换初等矩阵</li>
<li>倍加初等矩阵</li>
</ol>
<p><strong>性质1：初等矩阵$P$左乘矩阵$A$，其乘积$PA$就是矩阵$A$做一次与$P$相同的行变换。</strong></p>
<p><strong>性质2：初等矩阵$P$右乘矩阵$A$，其乘积$AP$就是矩阵$A$做一次与$P$相同的列变换。</strong></p>
<font color=red>tip:初等矩阵在左边，则矩阵做相同的行变换；初等矩阵在右边，则矩阵做相同的列变换。</font>

<p><strong>例：</strong></p>
<script type="math/tex; mode=display">
\begin{bmatrix} 0&1&0\\1&0&0\\0&0&1 \end{bmatrix}
\begin{bmatrix} 1&4&7\\2&5&8\\3&6&9 \end{bmatrix}=
\begin{bmatrix} 2&5&8\\1&4&7\\3&6&9 \end{bmatrix}</script><p>初等矩阵在左，且为单位矩阵第一、二行交换位置所得，则两矩阵相乘的结果为该矩阵第一、二行交换。</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&4&7\\2&5&8\\3&6&9 \end{bmatrix}\begin{bmatrix} 1&0&0\\0&1&0\\0&0&2 \end{bmatrix}=
\begin{bmatrix} 1&4&14\\2&5&16\\3&6&18 \end{bmatrix}</script><p>初等矩阵在右，且为单位矩阵第三列乘以$2$所得，则两矩阵相乘的结果为该矩阵第三列乘以$2$。</p>
<p><strong>性质3： 倍加初等矩阵的逆矩阵为将倍数改为相反数的矩阵。</strong></p>
<p>例： </p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&0&5\\0&1&0\\0&0&1 \end{bmatrix}^{-1}=
\begin{bmatrix} 1&0&-5\\0&1&0\\0&0&1 \end{bmatrix}</script><p><strong>性质4： 互换初等矩阵的逆矩阵为本身</strong></p>
<p>例：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&0&0\\0&0&1\\0&1&0 \end{bmatrix}^{-1}=
\begin{bmatrix}  1&0&0\\0&0&1\\0&1&0  \end{bmatrix}</script><p><strong>性质5： 倍乘初等矩阵的逆矩阵为将倍数改为倒数的矩阵</strong></p>
<p>例：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&0&0\\0&k&0\\0&0&1 \end{bmatrix}^{-1}=
\begin{bmatrix}  1&0&0\\0&\frac{1}{k} &0\\0&0&1  \end{bmatrix}</script><hr>
<h2 id="三、矩阵等价"><a href="#三、矩阵等价" class="headerlink" title="三、矩阵等价"></a>三、矩阵等价</h2><p>矩阵$A$经过有限次初等变换变成矩阵$B$，则称$A$与$B$等价，记成$A \cong B$,若$A \cong \begin{bmatrix} E_r &amp; 0\0&amp;0\end{bmatrix}$,则称后者为$A$的等价标准形($A$的等价标准形是与$A$等价的所有矩阵中的最简矩阵)。</p>
<p>矩阵等价满足：</p>
<ol>
<li>反身性：$A \cong A$</li>
<li>对称性：若$A\cong B$,则$B\cong A$</li>
<li>传递性：若$A\cong B,B\cong C$,则$A\cong C$</li>
</ol>
<hr>
<h2 id="四、行阶梯矩阵"><a href="#四、行阶梯矩阵" class="headerlink" title="四、行阶梯矩阵"></a>四、行阶梯矩阵</h2><p>设$A为m\times n$矩阵，若满足：</p>
<ol>
<li><strong>如果矩阵中有零行(即这一行元素全是0)，则零行在矩阵的底部</strong></li>
<li><strong>每个非零行的主元(即该行最左边的第一个非零元)，它们的列指标随着行指标的递增而严格增大</strong></li>
</ol>
<p>则称$A$为行阶梯矩阵。</p>
<p><img src="https://i.loli.net/2021/03/26/RCmyWA7Ojr46DcH.png" alt="image-20210326151306345"></p>
<hr>
<h2 id="五、行最简矩阵"><a href="#五、行最简矩阵" class="headerlink" title="五、行最简矩阵"></a>五、行最简矩阵</h2><p>设$A为m\times n$矩阵，若满足：</p>
<ol>
<li>是行阶梯矩阵</li>
<li>非零行的主元都是$1$,且主元所在列的其他元素都是$0$.</li>
</ol>
<p>则称其为行最简矩阵。</p>
<p><img src="https://i.loli.net/2021/03/26/dC25L1SkPepXywr.png" alt="image-20210326152004706"></p>
<hr>
<h2 id="六、初等行变换求逆矩阵"><a href="#六、初等行变换求逆矩阵" class="headerlink" title="六、初等行变换求逆矩阵"></a>六、初等行变换求逆矩阵</h2><p>设$A$为$n$阶矩阵:</p>
<script type="math/tex; mode=display">
(A|E) \rightarrow …(有限次初等行变换) \rightarrow (E|A^{-1})</script><ol>
<li>在$x=A^{-1}B$结构中求$x$的值时：</li>
</ol>
<p>将$A$和$B$两个矩阵拼接在一起，再进行初等行变换，转化为$Ex$</p>
<p>求得$x$</p>
<ol>
<li>在$x=BA^{-1}$结构中求$x$的值时(利用转置)：</li>
</ol>
<p>$x^{T}=(BA^{-1})^{T}=(A^T)^{-1}B^T$，将$A^T$和$B^T$两个矩阵拼接在一起，再进行初等行变换，转化为$Ex^T$，最后求得$x$</p>
<hr>
<h2 id="七、秩的概念"><a href="#七、秩的概念" class="headerlink" title="七、秩的概念"></a>七、秩的概念</h2><blockquote>
<p>$K$阶行列式：在$m \times n$矩阵$A$中，任取$K$行与$K$列($K \le m,K \le n$)。位于这些行与列的交叉点上的$K^2$个元素，按其在原来和矩阵$A$的次序可构成一个$K$阶行列式，称其为矩阵$A$的一个$K$阶子式。</p>
<p> 秩：若矩阵$A$中存在$r$阶子式不为$0$，$r+1$阶子式(如果存在)全为$0$，则对称矩阵$A$的秩为$r$，记为$r(A)=r$,零矩阵的秩规定为$0$</p>
</blockquote>
<font color =red>定理：经过初等变换矩阵的秩不变。</font>

<font color=red>推论：若可逆矩阵$ P,Q$,使得$PAQ=B$,则$r(A)=r(B)$ 。即一个矩阵做有限次初等行变换和初等列变换之后，秩不变。  </font> 

<p>秩的性质：</p>
<ol>
<li>$0 \le r(A_{m \times n}) \le min(m,n)$</li>
<li>$r(A^T)=r(A)$</li>
<li>$r(A+B) \le r(A) + r(B)$</li>
<li>$r(kA)=r(A)\quad k\neq0$ </li>
<li>$r(AB) \le min(r(A),r(B))$</li>
<li>如果$P,Q$可逆，则$r(PAQ)=r(A),r(PA)=r(A),r(AQ)=r(A)$</li>
<li>$r\begin{bmatrix} A &amp; 0 \ 0 &amp; B \end{bmatrix}=r(A)+r(B)$</li>
<li>$max(r(A),r(B)) \le r(A|B) \le r(A)+r(B)$    （中间是A的增广矩阵）</li>
</ol>
<font color=red>通过秩判断方程组是否有解：</font>

<p><img src="https://i.loli.net/2021/03/28/enUFu4zOrpsidKM.png" alt="image-20210328233251773"></p>
<p>将方程组的增广矩阵通过初等变换变换为以下形式：</p>
<p><img src="https://i.loli.net/2021/03/28/Xlkot6aT8KPB5jU.png" alt="image-20210328233325036"></p>
<ul>
<li>若$d_{r+1} \ne 0$，则方程组无解</li>
<li>若$d_{r+1}=0$，则方程组有解</li>
</ul>
<p>定理(方程组有解判定)：$n$元线性方程组 $Ax=b$</p>
<ol>
<li>无解$\quad \leftrightarrow \quad r(A)+1=r( \overline A)$</li>
<li><p>唯一解$\quad \leftrightarrow \quad r(A)=r( \overline A)=n$</p>
</li>
<li><p>无穷多解$\quad \leftrightarrow \quad r(A)=r( \overline A)&lt;n$</p>
</li>
</ol>
<p>定理: $n$元齐次线性方程组$AX=B$有解$\quad \leftrightarrow \quad r(A,B)&lt;n$</p>
]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>HOG特征提取</title>
    <url>/2021/04/02/xd6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="原文链接：戳这里！"><a href="#原文链接：戳这里！" class="headerlink" title="原文链接：戳这里！"></a>原文链接：<a href="https://zhuanlan.zhihu.com/p/85829145">戳这里！</a></h3><h2 id="HOG"><a href="#HOG" class="headerlink" title="HOG"></a>HOG</h2><h2 id="前言：特征描述符"><a href="#前言：特征描述符" class="headerlink" title="前言：特征描述符"></a>前言：特征描述符</h2><p>特征描述符就是通过提取图像的有用信息，并且丢弃无关信息来简化图像的表示。</p>
<p>HOG特征描述符可以将3通道的彩色图像转换成一定长度的特征向量。</p>
<span id="more"></span>
<div class="admonition info"><p class="admonition-title">Info</p><p>什么是有用信息，什么是无用信息？</p>
</div>

<p>这里的“有用”，是指对于什么目的有用，显然特征向量对于观察图像是没有用的，但是它对于像图像识别和目标检测这样的任务非常有用。当将这些特征向量输入到类似支持向量机($svm$)这样的图像分类算法中时，会得到较好的结果。</p>
<p>那什么样的“特征”对分类任务是有用，比如我们想检测出马路上的车道线，那么我们可以通过边缘检测来找到这些车道线，在这种情况下，边缘信息就是“有用的”，而颜色信息是无关的。</p>
<p><strong>在HOG特征描述符中，梯度方向的分布，也就是梯度方向的直方图被视作特征。图像的梯度(x和y的导数)非常有用，因为边缘和拐角周围幅度梯度很大，并且边缘和拐角比平坦区域包含更多关于物体形状的信息。</strong></p>
<p>方向梯度直方图(HOG)特征描述符常和线性支持向量机(SVM)配合使用，用于训练高精度的目标分类器。</p>
<h2 id="一、计算图像的方向梯度直方图-HOG-步骤"><a href="#一、计算图像的方向梯度直方图-HOG-步骤" class="headerlink" title="一、计算图像的方向梯度直方图(HOG)步骤"></a>一、计算图像的方向梯度直方图(HOG)步骤</h2><p>以下图为例子：</p>
<p><img src="https://i.loli.net/2021/04/21/FPhj3Xx5ftzdSH1.png" alt="image-20210421193206285"></p>
<h3 id="1-图像预处理"><a href="#1-图像预处理" class="headerlink" title="1. 图像预处理"></a>1. <strong>图像预处理</strong></h3><ul>
<li><p>对图像进行裁剪，缩放到固定的尺寸。</p>
</li>
<li><p>灰度处理是可选操作，灰度图像和彩色图像都可以用于计算梯度图。对于彩色图像，先对三通道颜色值分别计算梯度，然后取梯度值最大的作为该像素的梯度。</p>
</li>
<li><p>进行伽马矫正，调节图像对比度来减少光照对图像的影响(包括光照不均和局部阴影)，使过曝或者欠曝的图像恢复正常。</p>
</li>
<li><p>附：伽马矫正公式</p>
<script type="math/tex; mode=display">
f(x)= {x}^{\gamma}</script><p>即输出图像是输入图像的幂函数，指数为$\gamma$  。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;a.jpg&#x27;</span>)</span><br><span class="line">gamma = [<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">5.0</span>,<span class="number">10.0</span>]</span><br><span class="line">plt.figure(figsize = (<span class="number">15</span>,<span class="number">15</span>))</span><br><span class="line"><span class="keyword">for</span> idx,i <span class="keyword">in</span> <span class="built_in">enumerate</span>(gamma):</span><br><span class="line">    plt.subplot(<span class="number">221</span>+idx)</span><br><span class="line">    plt.title(<span class="string">&quot;gamma:%s&quot;</span>%<span class="built_in">str</span>(i))</span><br><span class="line">    img2 = np.power(img/<span class="built_in">float</span>(np.<span class="built_in">max</span>(img)),i)</span><br><span class="line">    plt.imshow(img2)</span><br><span class="line">    </span><br><span class="line">plt.savefig(<span class="string">&#x27;b.jpg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>$\gamma$越大，图像越暗，为1不变。</p>
<p><img src="https://i.loli.net/2021/04/21/YH7N34q8yMSuacb.jpg" alt="b"></p>
</li>
</ul>
<h3 id="2-计算梯度图"><a href="#2-计算梯度图" class="headerlink" title="2. 计算梯度图"></a>2. <strong>计算梯度图</strong></h3><p>为了得到梯度直方图，首先需要计算水平和垂直梯度，这可以通过使用一下内核过滤图像来实现，分别用于计算水平梯度和垂直梯度。</p>
<p><img src="https://i.loli.net/2021/04/21/GJnaviMFR6p53fP.png" alt="image-20210421200805443"></p>
<p>之后再计算$x$和$y$方向的梯度，包括幅值和方向：</p>
<script type="math/tex; mode=display">
g = \sqrt(g^2_{x}+g^2_y)\\
\theta = arctan{\frac{g_y}{g_x}}</script><div class="admonition warning"><p class="admonition-title">Warning</p><p>注意梯度方向会取绝对值，因此得到的角度范围为0-180。</p>
</div>

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;a.jpg&#x27;</span>)</span><br><span class="line"><span class="comment">#归一化</span></span><br><span class="line">img = np.float32(img) / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算x和y方向上的梯度</span></span><br><span class="line">gx = cv2.Sobel(img, cv2.CV_32F, <span class="number">1</span>, <span class="number">0</span>, ksize = <span class="number">1</span>)</span><br><span class="line">gy = cv2.Sobel(img, cv2.CV_32F, <span class="number">0</span>, <span class="number">1</span>, ksize = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算合梯度的方向和幅值</span></span><br><span class="line">mag, angle = cv2.cartToPolar(gx, gy, angleInDegrees=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/21/57X9ONGr2YqHwFL.jpg" alt="c"></p>
<h3 id="3-计算梯度直方图"><a href="#3-计算梯度直方图" class="headerlink" title="3. 计算梯度直方图"></a>3. <strong>计算梯度直方图</strong></h3><p>在这一步，我们先将整个图像划分为若干个8X8的小单元，称作cell，计算每个cell的梯度直方图。这个cell的尺寸也可以是其他值，根据具体特征而定。</p>
<div class="admonition attention"><p class="admonition-title">Attention</p><p>为什么我们要将图像分为若干个8X8的小单元？</p>
</div>

<p>因为一整张梯度图，其中的有效特征是非常稀疏的，不但运算量大，而且效果可能不好。于是我们用特征描述符来表示更紧凑的特征。一个8X8的小单元就包含了8X8X2=128个值(每个像素点包括梯度大小和梯度方向)。</p>
<p>现在将这8X8的小单元用长度为9的数组来表示，这个数组就是梯度直方图。</p>
<div class="admonition attention"><p class="admonition-title"> 为什么是长度为9的数组呢？
</p><p>因为梯度方向范围是0-180，将角度范围分为9份，每20°为一bins，<strong>将每一份中所有像素的梯度值进行累加</strong>（注意不是角度范围内像素的个数），得到9个数值。直方图就是由这9个数值所组成的数组，对应角度0°、20°、40°…160°</p>
</div>

<p><img src="https://i.loli.net/2021/04/21/c5HBGowzRFshCMQ.png" alt="image-20210421205314930"></p>
<p>比如上面方向图中蓝圈包围的像素，角度为80度，这个像素对应的幅值为2，所以在直方图80度对应的bin加上2。红圈包围的像素，角度为10度，介于0度和20度之间，其幅值为4，那么这个梯度值就被按比例分给0度和20度对应的bin，也就是各加上2。</p>
<div class="admonition warning"><p class="admonition-title">Warning</p><p>还有一个细节需要注意，如果某个像素的梯度角度大于160度，也就是在160度到180度之间，那么把这个像素对应的梯度值按比例分给0度和160度对应的bin。</p>
</div>

<p>现在我们就可以用这9个数的梯度直方图来代替原来很大的三维矩阵，即代替了8x8x2个值。</p>
<p>这种表示法不仅使特征更紧凑，而且对单个像素值的变化不敏感，也就是能够抗噪声干扰。</p>
<h3 id="4-Block归一化"><a href="#4-Block归一化" class="headerlink" title="4. Block归一化"></a>4. <strong>Block归一化</strong></h3><p>上一步中将8X8的区域做为一个cell，接着再以2X2个cell做为一组，称为block。由于每个cell有9个值，所以2X2个cell有36个值。HOG通过滑动窗口的方式来获得Block。</p>
<p>在第三步中，我们对每个cell创建了一个直方图，但是图像的梯度直方图对整体光照非常敏感，比如通过将所有像素值除以2来使图像变暗，那么梯度幅值将减小一半，因此直方图中的值也将减少一半。如果希望我们的特征描述符不会受到光照变化的影响，那么我们就需要将直方图归一化。</p>
<p>首先，以长度为3的向量为例：假设我们有一个向量 <code>[128,64,32]</code>，向量的长度为  </p>
<script type="math/tex; mode=display">
\sqrt{128^2+64^2+32^2}=146.64</script><p>这叫做向量的L2范数。将这个向量的每个元素除以146.64就得到了归一化向量 <code>[0.87, 0.43, 0.22]</code>。</p>
<p>现在有一个新向量，是第一个向量的2倍<code>[128x2, 64x2, 32x2]</code>，也就是 <code>[256, 128, 64]</code>，我们将这个向量进行归一化，你可以看到归一化后的结果与第一个向量归一化后的结果相同。所以，对向量进行归一化可以消除整体光照的影响。</p>
<p>知道了如何归一化，现在来对block的梯度直方图进行归一化（注意不是cell），一个block有4个直方图，将这4个直方图拼接成长度为36的向量，然后对这个向量进行归一化。</p>
<p>因为使用的是滑动窗口，滑动步长为8个像素(即一个cell)，所以每滑动一次，就在这个窗口上进行归一化计算得到长度为36的向量，并重复这个过程。</p>
<h3 id="5-计算HOG特征向量"><a href="#5-计算HOG特征向量" class="headerlink" title="5. 计算HOG特征向量"></a>5. <strong>计算HOG特征向量</strong></h3><p>最后计算真个图像的特征描述符，每滑动一次就得到一个长度为36的特征向量。那么总共有多少特征向量呢？</p>
<p>比如上面这个图，将整幅图像划分成cell的个数为8x16，就是横向有8个cell，纵向有16个cell。每个block有2x2个cell的话，那么cell的个数为：(16-1)x(8-1)=105。即有7个水平block和15个竖直block。</p>
<p>再将这105个block合并，就得到了整个图像的特征描述符，长度为 105×36=3780。</p>
<h3 id="6-HOG可视化"><a href="#6-HOG可视化" class="headerlink" title="6. HOG可视化"></a>6. HOG可视化</h3><p>使用Python库skimage</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> feature, exposure</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;a.jpg&#x27;</span>)</span><br><span class="line">fd, hog_image = feature.hog(image, orientations=<span class="number">9</span>, pixels_per_cell=(<span class="number">16</span>, <span class="number">16</span>),cells_per_block=(<span class="number">2</span>, <span class="number">2</span>), visualize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Rescale histogram for better display</span></span><br><span class="line">hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, image)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;hog&#x27;</span>, hog_image_rescaled)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/21/N3IzwclpEM8iZ6r.png" alt="image-20210421213911095"></p>
<p>这里最关键的函数就是 feature.hog，关键参数如下：</p>
<ul>
<li>image : 可以是灰度图或者彩色图</li>
<li>orientations : 把180度分成几份，也就是bin的数量</li>
<li>pixels_per_cell : 一个cell中的像素数目</li>
<li>cells_per_block : 一个block中包含的cell个数</li>
<li>visualize : 是否返回一个hog图像用于显示。</li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>hog</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo警示框插件</title>
    <url>/2021/04/04/xj-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<div class="admonition info"><p class="admonition-title"> Hexo-admonition插件地址
</p><p>戳这里！<a href="https://github.com/lxl80/hexo-admonition">传送门</a></p>
</div>

<span id="more"></span>
<div class="admonition warning"><p class="admonition-title">Warning</p><p>在typora中编辑Markdown时使用 shift+回车，
使用中文四个空格，不能用Tab或者英文空格</p>
</div>

<p><img src="https://i.loli.net/2021/04/05/WxldP8HzRBjrMcN.png" alt="image-20210405020009290"></p>
<p><del>谨以此篇纪念深夜的两个小时</del></p>
]]></content>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
</search>
