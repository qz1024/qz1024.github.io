<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最大的矩形</title>
    <url>/2021/03/16/acm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p><a href="http://118.190.20.162/view.page?gpid=T3">题目链接</a></p>
<p><img src="https://gitee.com/qztanging/images/raw/master/img/acm_1.png" alt="题目描述" title="描述"><br><span id="more"></span></p>
<p><img src="https://gitee.com/qztanging/images/raw/master/img/acm_2.png" alt="题目描述"></p>
<hr>
<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><ul>
<li>首先看数据范围：1&lt;= n &lt;= 1000 &amp;&amp; 1&lt;= hi &lt;= 10000 ,需要时间复杂度小于等于 O(n<sup>2</sup>) </li>
<li>确定枚举的对象，本题中可以枚举矩形的上边界。知道矩形的上边界和左右边界之后就可以确定一个矩形。枚举矩形的上边界，设横坐标为 i ，高度为 h，经过观察可以发现，上边界确定之后，以该边为上边界的最大矩形就可以确定：左边界为 i 前左数高度第一个小于 h 的；右边界为i 后往右数高度第一个小于 h 的。之后更新最大矩形。</li>
</ul>
<hr>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> n,re,ans;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="comment">//枚举上边界</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = i,r = i;</span><br><span class="line">        <span class="comment">//搜索左边界</span></span><br><span class="line">		<span class="keyword">while</span>(l&gt;= <span class="number">1</span> &amp;&amp; h[l]&gt;= h[i])&#123;</span><br><span class="line">			l--;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//搜索右边界</span></span><br><span class="line">		<span class="keyword">while</span>(r &lt;= n &amp;&amp; h[r] &gt;= h[i])&#123;</span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//计算矩形面积，注意r - l之后需要减1.</span></span><br><span class="line">		re = (r - l - <span class="number">1</span>)*h[i];</span><br><span class="line">		ans = max(re,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的数</title>
    <url>/2021/03/17/acm2-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、-题目描述"><a href="#一、-题目描述" class="headerlink" title="一、 题目描述"></a>一、 题目描述</h2><p><a href="http://118.190.20.162/view.page?gpid=T2">题目链接</a></p>
<p><img src="https://gitee.com/qztanging/images/raw/master/img/a.jpg" alt="描述"><br><span id="more"></span></p>
<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><ul>
<li><p>题目中有三个要求，可以将0和1看作第一类，2和3看作第一类，然后就是排列组合问题。</p>
</li>
<li><p>首先设第一类数个数为 <strong>k</strong> ，则第二类数个数为 <strong>n - k</strong>。<strong>k</strong>的范围为：[2 ，n - 2] </p>
</li>
<li><p>从k个位置中选取第一类的位置，因为最高为不能为0，所以第一类的可能位置有 :</p>
<script type="math/tex; mode=display">
C_{n-1}^{k}</script></li>
<li><p>之后具体分第一类中0和1的位置，因为 <strong>0</strong> 在<strong>1</strong>的前面且必须有一个，所以第一类里面的情况有  <strong>k-1</strong> 种：01111…11(一个0和k-1个1)  和00111…111(两个0和k-2个1)  到 0000…0001  (k-1个0和共1个1)。</p>
</li>
<li><p>同理第二类数字中的位置情况： <strong>n - k - 1</strong>种。</p>
</li>
<li><p><strong>综上所述</strong>，方案数为：</p>
<script type="math/tex; mode=display">
\sum_{k=2}^{n-2}  C_{n-1}^{k} \times (k-1) \times (n-k-1)</script></li>
</ul>
<hr>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>,mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,re,t,c[N][N];</span><br><span class="line"><span class="comment">//组合数数组的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;= i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)  c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n<span class="number">-2</span> ; i++)&#123;</span><br><span class="line">        <span class="comment">//因为可能超范围，所以转换为long,相乘的中间也要模一下</span></span><br><span class="line">        re =( re +  (ll)c[n<span class="number">-1</span>][i]*(i<span class="number">-1</span>)%mod  *(n<span class="number">-1</span>-i)  )%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式概念</title>
    <url>/2021/03/21/post/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="一、二三阶行列式"><a href="#一、二三阶行列式" class="headerlink" title="一、二三阶行列式"></a>一、二三阶行列式</h2><h3 id="1-二阶行列式定义"><a href="#1-二阶行列式定义" class="headerlink" title="1. 二阶行列式定义"></a>1. 二阶行列式定义</h3><script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a&&b\\
c&&d
\end{array}
\right|
=ad-bc</script><p>同时从左上到右下称为<strong>主对角线</strong>，左下到右上称为<strong>副对角线</strong>。</p>
<span id="more"></span>
<h3 id="2-代入一元二次方程组"><a href="#2-代入一元二次方程组" class="headerlink" title="2. 代入一元二次方程组"></a>2. 代入一元二次方程组</h3><p>对于一元二次方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
a_1x+b_1y=c_1\\
a_2x+b_2y=c_2
\end{cases}</script><p>通过加减消元，我们可以得到：</p>
<script type="math/tex; mode=display">
(a_1b_2-a_2b_1)x=c_1b_2-c_2b_1\\
(a_2b_1-a_1b_2)y=c_1a_2-c_2a_1</script><p>如果系数行列式</p>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a_1&&b_1\\
a_2&&b_2
\end{array}
\right|
=a_1b_2-a_2b_1\neq0</script><p>则方程组有唯一解，即：</p>
<script type="math/tex; mode=display">
\begin{cases}
x=
\frac
{\left|
\begin{array}
{ccc}
c_1&&b_1\\
c_2&&b_2
\end{array}
\right|}
{\left|
\begin{array}
{ccc}
a_1&&b_1\\
a_2&&b_2
\end{array}
\right|}\\
y=
\frac
{\left|
\begin{array}
{ccc}
a_1&&c_1\\
a_2&&c_2
\end{array}
\right|}
{\left|
\begin{array}
{ccc}
a_1&&b_1\\
a_2&&b_2
\end{array}
\right|}
\end{cases}</script><p>例：解下列方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
3x+2y=5\\
5x-7y=29
\end{cases}</script><blockquote>
<p>解：由于系数行列式</p>
<script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
3&&2\\5&&-7
\end{array}
\right|
=-21-10=-31\neq0</script><p>所以方程组有唯一解</p>
<p>所以：</p>
<script type="math/tex; mode=display">
x=
\frac
{\left|
\begin{array}
{ccc}
5&&2\\29&&-7
\end{array}
\right|}
{-31}=3,
y=
\frac
{\left|
\begin{array}
{ccc}
3&&5\\5&&29
\end{array}
\right|}
{-31}=-2</script></blockquote>
<h3 id="3-三阶行列式"><a href="#3-三阶行列式" class="headerlink" title="3. 三阶行列式"></a>3. 三阶行列式</h3><script type="math/tex; mode=display">
\left|
\begin{array}
{ccc}
a_{11}&&a_{12}&&a_{13}\\
a_{21}&&a_{22}&&a_{23}\\
a_{31}&&a_{32}&&a_{33}
\end{array}
\right|=\\a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-\\a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{
23}a_{32}</script><font color=red>不同行不同列元素乘积的代数和</font>



<hr>
<h2 id="二、排列、逆序、逆序数"><a href="#二、排列、逆序、逆序数" class="headerlink" title="二、排列、逆序、逆序数"></a>二、排列、逆序、逆序数</h2><h3 id="1-排列"><a href="#1-排列" class="headerlink" title="1. 排列"></a>1. 排列</h3><blockquote>
<p>排列：由1,2,···,n组成的有序数组称为一个 <strong>n</strong> 阶排列。通常用 $j_1,j_2,j_3,···,j_n$表示 <strong>n</strong>阶排列。</p>
<p>自然排列：从1到n从小到大顺序排列成为自然排列。</p>
</blockquote>
<p>例： 2    4     1    3    ：4阶排列</p>
<p>​        1    3    5    4    2    ：5阶排列</p>
<h3 id="2-逆序与逆序数"><a href="#2-逆序与逆序数" class="headerlink" title="2. 逆序与逆序数"></a>2. 逆序与逆序数</h3><blockquote>
<p>逆序：在一个排列中，如果一个大的数排在一个小的数前面，就称这两个数构成一个逆序。</p>
<p>逆序数：一个排列中逆序的总数为这个排列的逆序数。用$\tau(j_1,j_2,···,j_n)$表示相关排列的逆序数。</p>
<p>偶排列：如果一个排列的逆序数为偶数，则称这个排列为偶排列</p>
<p>奇排列：如果一个排列的逆序数为奇数，则称这个排列为奇排列</p>
</blockquote>
<p>例：$\tau(1\,3\,2)=0+1=1$</p>
<p>​        $\tau(2\,4\,3\,1)=1+2+1=4$</p>
<h3 id="3-定理"><a href="#3-定理" class="headerlink" title="3.定理"></a>3.定理</h3><ul>
<li>对换改变排列的奇偶性</li>
<li>任意一个$n$阶排列可经过一系列兑换变成自然排列</li>
<li>在所有的$n$阶排列中，奇偶排列各占一半</li>
</ul>
<hr>
<h2 id="三、n阶行列式概念"><a href="#三、n阶行列式概念" class="headerlink" title="三、n阶行列式概念"></a>三、n阶行列式概念</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><img src="https://i.loli.net/2021/03/21/rpPKtdU9Tsq1vRk.png" alt="定义"></p>
<p>完全展开式有$n!$项。</p>
]]></content>
      <categories>
        <category>线代</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
</search>
